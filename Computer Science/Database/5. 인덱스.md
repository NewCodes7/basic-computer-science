# 인덱스

## 인덱스의 필요성

<img width="550" alt="image" src="https://github.com/BCS-study/basic-computer-science/assets/123712285/4b9a0d3c-e1a7-4662-9f64-c0426a072a17">

- 인덱스: 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
- 필요성: 테이블 안에 찾고자 하는 데이터를 빠르게 찾을 수 있다.
    - 만약 index를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색하는 Full Scan을 수행해야 한다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

### 인덱스의 관리

- DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다.
- 그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.
    - INSERT: 새로운 데이터에 대한 인덱스를 추가함
    - DELETE: 삭제하는 데이터의 인덱스를 **사용하지 않는다는** 작업을 진행함
    - UPDATE: 기존의 인덱스를 **사용하지 않음** 처리하고, 갱신된 데이터에 대해 인덱스를 추가함

### 인덱스의 장점과 단점

- 장점
    - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
    - 전반적인 시스템의 부하를 줄일 수 있다.
- 단점
    - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
    - 인덱스를 관리하기 위해 추가 작업이 필요하다.
    - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.
- 만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 **인덱스의 크기가 비대해져서 성능이 오히려 저하**되는 역효과가 발생할 수 있다.
    - DELETE와 UPDATE 연산을 수행할 때 기존의 인덱스를 ‘사용하지 않음’ 처리를 하기에 실제 데이터보다 인덱스는 훨신 많이 존재할 수 있기 때문이다.

### 인덱스를 사용하면 좋은 경우

- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

## B-트리

<img width="550" alt="image" src="https://github.com/BCS-study/basic-computer-science/assets/123712285/d3f2c271-459d-4bc3-94e7-d7daa01f883f">

- 개요
    - 인덱스는 보통 B-트리라는 자료구조로 이루어져 있다.
    - 이진트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조
- 구성
    - 루트 노드
    - 리프 노드
    - 브랜치 노드

### 인덱스가 효율적인 이유

1. 균형 잡힌 트리 구조: 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 구조를 가지고 있다.
2. 대수확장성: 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장한다.
    1. 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가한다.

## 인덱스 만드는 방법

- 개요: 인덱스를 만드는 방법은 데이터베이스마다 다르며, MySQL과 MongoDB를 기준으로 설명한다.

### MySQL

- 클러스터형 인덱스
    - 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스가 더욱 성능이 좋다.
        - ex) age라는 하나의 필드만으로 쿼리를 보낼 때
    - 테이블당 하나를 설정할 수 있다.
    - primary key 옵션으로 기본키를 만들면 생성할 수 있다.
- 세컨더리 인덱스
    - 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스이다.
        - ex) age, name, email 등 다양한 필드를 기반으로 쿼리를 보낼 때
    - 기본키로 만들지 않고 unique not null 옵션을 붙이면 생성할 수 있다.
    - ‘create index…’ 명령어를 기반으로 생성한다.

### MongoDB

- 기본키
    - 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정된다.
- 세컨더리키
    - 세컨더리키도 부가적으로 설정해서 기본키와 함께 복합 인덱스를 설정할 수 있다.

## 인덱스 최적화 기법

- 개요: 인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같기에 해당 문서에서는 MongoDB를 기반으로 설명한다.
- 사전 개념: 인덱스는 비용이다.
    - 인덱스는 두 번 탐색하도록 강요하기에 관련 읽기 비용이 든가. (인덱스 리스트 → 컬렉션)
    - 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다. (이때 B-트리의 높이를 균형 있게 조절하는 비용, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 함께 든다.)
    - 그렇기에 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 비효율적
        - 또한, 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 건 비효율
- 항상 테스팅하라.
    - 인덱스 최적화 기법은 서비스 특징에 따라 달라진다. 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문이다.
    - 이러한 변동성 때문에 항상 테스팅하는 것이 중요하다.
    - explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 한다.
- 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.
    - 보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성한다.
    - 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다.
    1. 같음: 어떠한 값을 비교하는 ==이나 equal 쿼리가 있다면 제일 먼저 인덱스로 설정한다.
    2. 정렬: 정렬에 쓰는 필드라면 ‘같음’ 다음 인덱스로 설정한다.
    3. 다중 값: 다중 값을 출력해야 하는 필드(쿼리 자체가 > 이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰이는 필드)하면 나중에 인덱스를 설정한다.
    4. 카디널리티: 카디널리티가 높은 순서를 기반으로 인덱스를 생성한다.
        
        > 카디널리티: 유니크한 값의 정도 (ex. email > age)
        > 

## 레퍼런스

- 이미지 출처
    - 인덱스 필요성: https://mangkyu.tistory.com/96
    - B-Tree: [https://velog.io/@emplam27/자료구조-그림으로-알아보는-B-Tree](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree)