# HTTP

## 개요

해당 문서는 HTTP의 역할과 특징, 발전 과정에 대해 다룹니다. 

## HTTP (Hypertext Transfer Protocol)

- 의미: 웹에서 데이터를 주고받는 서버-클라이언트 모델의 프로토콜
- 개요
    - 애플리케이션 계층으로서 웹 서비스 통신에 사용
    - TCP/IP를 이용하는 응용 프로토콜
    - HTTP 1.0부터 시작해서 발전을 거듭하여 지금은 HTTP/3
- 특징
    1. 클라이언트-서버 구조: 클라이언트가 요청을 하기 위해 연결을 연 다음, 응답을 받을때 까지 대기하는 전통적인 [클라이언트-서버 모델](https://en.wikipedia.org/wiki/Client%E2%80%93server_model)을 따름
    2. 비연결성: HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜
    3. 무상태: 서버가 클라이언트의 상태를 보존하지 않음

### 쿠키와 세션

- 배경: HTTP의 특징이자 단점인 비연결성과 무상태을 해결하기 위해 쿠키와 세션을 사용
    - 예시: 통신이 끊어지면 상태정보가 유지되지 않기 때문에 매번 페이지를 이동할 때마다 로그인은 다시 해야 함
    - 예시: 상품 선택 후 구매 페이지에서 선택한 상품의 정보가 없어짐

### 쿠키

- 의미: 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일
- 역할
    - 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지
    - 클라이언트의 상태 정보를 로컬에 저장했다가 참조
    - 클라이언트에 300개까지 쿠키저장 가능, 하나의 도메인당 20개의 값만 가질 수 있음, 하나의 쿠키값은 4KB까지 저장
    - Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있음
    - 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송
- 구성 요소
    - 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름
    - 값 : 쿠키의 이름과 관련된 값
    - 유효시간 : 쿠키의 유지시간
    - 도메인 : 쿠키를 전송할 도메인
    - 경로 : 쿠키를 전송할 요청 경로
- 동작 방식
    1. 클라이언트가 페이지를 요청
    2. 서버에서 쿠키를 생성
    3. HTTP 헤더에 쿠키를 포함 시켜 응답
    4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
    5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
    6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답
- 사용 예시
    - 방문 사이트에서 로그인 시, "아이디와 비밀번호를 저장하시겠습니까?"
    - 쇼핑몰의 장바구니 기능
    - 자동로그인, 팝업에서 "오늘 더 이상 이 창을 보지 않음" 체크, 쇼핑몰의 장바구니

### 세션

- 의미: 쿠키를 기반하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리
- 역할
    - 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지
    - 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능
    - 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지
    - 즉, 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 되므로 성능 저하의 요인
    - 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 세션 ID
- 동작 방식
    1. 클라이언트가 서버에 접속 시 세션 ID를 발급 받음
    2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음
    3. 클라리언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청
    4. 서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라이언트 정보를 가져와서 사용
    5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답
- 특징
    - 각 클라이언트에게 고유 ID를 부여
    - 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
    - 보안 면에서 쿠키보다 우수
    - 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨
- 사용 예시
    - 로그인 같이 보안상 중요한 작업을 수행할 때 사용

### 쿠키와 세션의 차이

- 공통점
    - 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷함. 그 이유는 세션도 결국 쿠키를 사용하기 때문
- 가장 큰 차이점
    - **사용자의** **정보가 저장되는 위치** (쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용)
- 보안 & 속도
    - 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠름. 그 이유는 세션은 서버의 처리가 필요하기 때문
- 보안
    - 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약
    - 세션은 쿠키를 이용해서 session Id 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋음
- 라이프 사이클
    - 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있음
    - 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있음
    - 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됨
        - 예를 들어, 크롬에서 다른 탭을 사용해도 세션이 공유됨. 다른 브라우저를 사용하게 되면 다른 세션을 사용할 수 있음
- 세션을 사용하면 좋은데 왜 쿠키를 사용할까?
    - 서버의 자원 & 속도: 세션은 서버의 자원을 사용하기 때문에 무분별하게 만들다보면 서버의 메모리가 감당할 수 없어질 수가 있고 속도가 느려질 수 있기 때문에 쿠키가 유리한 경우가 있음
- 쿠키/세션은 캐시와 엄연히 다름!
    - 캐시: 캐시는 이미지나 css, js파일 등을 브라우저나 서버 앞 단에 저장해놓고 사용하는 것

## HTTP 요청

### 구성 요소

1. 시작 줄
2. 헤더
3. 본문

### HTTP 요청 예시

```markup
POST /signup HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "John Doe",
  "email": "johndoe@example.com"
}
```

- 시작 줄: **[HTTP 요청 메서드](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)**, URL 경로, HTTP 프로토콜 버전 정보
- 두 번째 줄 ~ 세 번째 줄: HTTP 요청의 헤더 (`key:value` 쌍)
- 그 이후 줄: HTTP 요청의 바디

### 시작 줄

1. **HTTP 메서드**: 클라이언트가 서버에게 특정 동작을 요청하는 방법을 정의
2. **요청 타겟**: 주로 [URL](https://developer.mozilla.org/ko/docs/Glossary/URL), 또는 프로토콜, 포트, 도메인의 절대 경로로 나타냄
3. **HTTP 버전**: 응답 메시지에서 써야 할 HTTP 버전을 알려주는 역할
    
    ### GET
    
    - 의미: 서버로부터 특정 리소스 요청 (Read)
    - URL에 쿼리 매개변수를 포함하여 데이터를 전달
    - 조회할 때 POST도 사용할 수 있지만, GET 메서드는 캐싱이 가능하기에 GET을 사용하는 것이 유리하다.
    - 예시: `GET /members/100?username=newcodes`
    
    ### POST
    
    - 의미: 서버로 데이터 제출하여 리소스 생성하거나 업데이트 요청 (Create)
    - HTTP Body에 데이터를 포함하여 전송
    - 만일 데이터를 GET 하는데 있어, JSON으로 조회 데이터를 넘겨야 하는 애매한 경우 POST를 사용
    
    ### PUT
    
    - 의미: 지정된 리소스의 업데이트 요청
    - 지정된 리소스의 전체 내용을 본문에 포함하여 전송
    - 만일 요청 메세지에 리소스가 있으면 덮어쓰고, 없으면 새로 생성한다.
    
    ### DELETE
    
    - 의미: 지정된 리소스 삭제 요청
    
    ### PATCH
    
    - 의미: 리소스 부분 변경 (PUT이 전체 변경, PATCH는 일부 변경)
    - 만일 PATCH를 지원하지 않는 서버에서는 대신에 POST를 사용

### 헤더

- 의미: 웹사이트 도메인의 호스트, 언어, 사용자의 브라우저 등 **서버가 필요한 정보**를 전달

### 본문

- 의미: POST, PUT 요청과 같이 **요청과 함께 전달되는 데이터**를 포함
- 배치: 요청의 마지막 부분에 들어가며, 모든 요청에 본문이 들어가지는 않음
    - `GET`, `HEAD`, `DELETE` , `OPTIONS`처럼 리소스를 가져오는 요청은 보통 본문이 필요없음
    - 일부 요청은 업데이트를 하기 위해 서버에 데이터를 전송
    - 보통 (HTML 폼 데이터를 포함하는) `POST` 요청일 경우에 그러함

## HTTP 응답

### 구성 요소

1. 상태 줄
2. 헤더
3. 본문

### HTTP 응답 예시

```
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2023 14:28:02 GMT
Server: Apache
Content-Type: text/html

<html>
...
</html>
```

- 첫 번째 줄: HTTP 프로토콜 버전 정보와 **[HTTP 상태 코드](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)**
- 두 번째 줄 ~ 네 번째 줄: HTTP 응답의 헤더 (`key:value` 쌍)
    - 헤더: 브라우저가 필요한 정보를 전달
- 다섯 번째 줄 ~ 마지막 줄: HTTP 응답의 Body
    - Body: 브라우저가 요청한 데이터 (위 예시에서는 HTML 데이터)

### 상태 줄

1. HTTP 버전: HTTP/1.1과 같은 HTTP 프로토콜의 버전
2. 상태 코드: 서버가 요청을 성공적으로 처리했는지 또는 오류가 발생했는지를 나타내는 숫자
3. 상태 텍스트: 상태 코드에 대한 간단한 설명을 나타내는 텍스트
    
    ### HTTP 상태 코드
    
    - **1XX: Informational(정보 제공)**
        - 임시 응답으로 현재 클라이언트의 요청까지는 처리되었으니 계속 진행하라는 의미
        - HTTP 1.1 버전부터 추가됨
    - **2XX: Success(성공)**
        - 클라이언트의 요청이 서버에서 성공적으로 처리되었다는 의미
    - **3XX: Redirection(리다이렉션)**
        - 완전한 처리를 위해서 추가 동작이 필요한 경우
        - 주로 서버의 주소 또는 요청한 URI의 웹 문서가 이동되었으니 그 주소로 다시 시도하라는 의미
    - **4XX: Client Error(클라이언트 에러)**
        - 없는 페이지를 요청하는 등 클라이언트의 요청 메시지 내용이 잘못된 경우를 의미
    - **5XX: Server Error(서버 에러)**
        - 서버 사정으로 메시지 처리에 문제가 발생한 경우
        - 서버의 부하, DB 처리 과정 오류, 서버에서 익셉션이 발생하는 경우를 의미
    
    ### HTTP 상태 텍스트
    
    - **200 OK**: 요청이 성공적으로 처리되었음을 나타냄
    - **404 Not Found**: 요청한 리소스를 찾을 수 없음을 나타냄
    - **500 Internal Server Error**: 서버에서 처리 중에 오류가 발생했음을 나타냄

## 그림으로 보는 HTTP의 역사

---

<img width="600" alt="image" src="https://github.com/BCS-study/basic-computer-science/assets/123712285/bdb7173b-9986-4c64-aa7e-1fe8a7bf9724">

<img width="600" alt="image" src="https://github.com/BCS-study/basic-computer-science/assets/123712285/b3399f57-0bee-49f0-9785-a5a583b44762">

## HTTP/1.0

---

- 설계: 기본적으로 한 연결 당 하나의 요청을 처리하도록 설계
    - 요청/응답 예시 이미지:
    
    <img width="600" alt="image" src="https://github.com/BCS-study/basic-computer-science/assets/123712285/ad37bd98-131b-4da3-bb4a-302414259598">
    
- 단점
    1. 설계 방식으로 인해 RTT 증가
        - RTT: 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간이며, 패킷 왕복 시간
    2. 서버로부터 파일을 가져올 때마다 3-way-handshake를 계속해서 열어야 함
- RTT 증가 해결 방법
    1. 이미지 스프라이트: 여러 개의 이미지를 하나의 이미지로 합쳐서 관리하는 이미지를 의미
    2. 코드 압축: 개행 문자, 빈칸을 없애서 코드의 크기를 최소화하는 방법
    3. 이미지 Base64 인코딩: 이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법
        1. 장점: 이미지에 대해 서버에 연결을 열고 HTTP 요청을 할 필요가 없음
        2. 인코딩: 정보의 형태나 형식을 다른 형태나 령식으로 변환하는 처리 방식

## HTTP/1.1

- 발전: 매번 TCP 연결하는 게 아니라 한 번 TCP 초기화한 이후, keep-alive라는 옵션으로 여러 개의 파일을 송수신할 수 있음
    - 참고 사항: HTTP/1.0에도 keep-alive 옵션 있었지만 표준화가 되어 있지 않았고, 1.1부터 표준화됨
    - 요청응답 예시 이미지:
        
        <img width="600" alt="image" src="https://github.com/BCS-study/basic-computer-science/assets/123712285/c3175021-3ae9-46cf-a7b6-4073c2628e76">
        
- 단점
    1. 대기 시간 증가: 문서 안에 포함된 다수의 리소스를 처리하려면 요청할 리소스 개수에 비례해서 대기 시간 길어짐
    2. HOL Blocking(Head Of Line Blocking): 네트워크에서 같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상
    3. 무거운 헤더 구조: 헤더에 쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무거움

## HTTP/2

- 발전: HTTP/1.x보다 지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있으며 각종 기능을 지원함
    - 각종 기능: 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리

### 멀티플렉싱

- 의미: 하나의 통신채널에서 여러 개의 스트림을 사용하여 둘 이상의 데이터(시그널)를 전송하는 데 사용되는 기술
    - 스트림: 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름
- 기존의 문제점 해결: 기존에는 각 요청마다 새로운 TCP 연결을 열어야 했지만, 하나의 TCP 연결로 여러 개의 요청과 응답을 주고받을 수 있음
- 특징: 특정 스트림의 패킷이 손실되었다고 해도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡하게 동작함

### 헤더 압축

- 기존의 문제점 해결: HTTP/1.x에는 크기가 큰 헤더라는 문제를 HTTP/2에서는 헤더 압축을 통해 해결
- 동작: 허프만 코딩 압축 알고리즘을 사용하여 HPACK 압축 형식을 가짐
    - 허프만 코딩: 문자의 출현 빈도에 따라서 다른 길이를 사용하여 압축하는 알고리즘
        1. 문자열을 문자 단위로 쪼개 빈도수를 카운트
        2. 빈도가 높은 정보는 적은 비트 수 사용하여 표현
        3. 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현

### 서버 푸시

- 기존의 문제점 해결: HTTP/1.1에서는 클라이언트가 서버에 요청을 해야 파일을 다운로드받을 수 있었지만, HTTP/2에서는 클라이언트 요청 없이 **서버가 바로 리소스를 푸시**할 수 있음

## HTTPS (Hypertext Transfer Protocol Secure)

- 의미: 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청
    - 이를 통해 통신을 암호화
    - HTTP/2는 HTTPS 위에서 동작

### SSL/TLS

- 의미: 전송 계층에서 보안을 제공하는 프로토콜로 제3자가 메시지를 도청하거나 변조하는 인터셉트 방지함
- 원리: **보안 세션**을 기반으로 하며, 데이터를 암호화하며 보안 세션이 만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 적용됨
- 보안 세션: 보안이 시작되고 끝나는 동안 유지되는 세션
    - 방법: SSL/TLS는 핸드셰이크를 통해 보안 세션 생성하고 이를 기반으로 상태 정보 공유
    - 세션: 운영체제가 어떠한 사용자로부터 자신의 자산 이용을 허락하는 일정한 기간

### SSL과 TLS 명칭에 관하여

- SSL(Secure Socket Layer)
    1. Netscape가 1995년 처음으로 SSL을 개발
    2. 1996년 SSL 3.0 이후 업데이트되지 않음
    3. 알려진 취약성이 여러가지 있으며 보안 전문가들은 SSL 사용 중단을 권장
- TLS(Transport Layer Security Protocol)
    1. SSL의 업데이트 버전으로 SSL의 최종버전인 3.0과 TLS의 최초버전의 차이는 크지 않음
    2. 이름이 바뀐것은 SSL을 개발한 Netscape가 업데이트에 참여하지 않게 되어 소유권 변경을 위함
    3. 결과적으로 TLS는 SSL의 업데이트 버전이며 명칭만 다름
- 결론: 보통 이를 합쳐 SSL/TLS라고 부름

### 보안 세션

- 의미: 보안이 시작되고 끝나는 동안 유지되는 세션
    - SSL/TLS는 핸드셰이크를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보 등을 공유
    - 세션: 운영체제가 어떠한 사용자로부터 자신의 자산 이용을 허락하는 일정한 기간이며, 사용자는 이 시간 동안 응용 프로그램, 자원 등을 사용할 수 있음

### HTTPS 구축 방법

1. 직접 CA에서 구매한 인증키를 기반으로 HTTPS 서비스 구축
2. 서버 앞단의 HTTPS를 제공하는 로드밸런서 두기
3. 서버 앞단에 HTTPS를 제공하는 CDN을 둬서 구축

## HTTP/3

- 의미: HTTP/1.1 및 HTTP/2와 함께 WWW에서 정보를 교환하는 데 사용되는 HTTP의 세 번째 버전
- 차이점: HTTP/2는 TCP 위에서 동작하지만, HTTP/3은 QUIC이라는 계층 위에서 동작하며 TCP가 아닌 UDP 기반으로 동작
- 참고 정보
    - 2012년, 구글에서 QUIC(Quick UDP Internet Connections)이라는 범용 전송 계층 네트워크 프로토콜을 발표
    - 2022년, IETF(국제 인터넷 표준화 기구)에서 QUIC 프로토콜을 기반으로 동작하는 HTTP/3 표준화 문서인 [RFC 9114](https://datatracker.ietf.org/doc/html/rfc9114)를 제정
    - 이런 흐름에 맞춰 [네이버가 국내에서 처음으로 HTTP/3 도입](https://zdnet.co.kr/view/?no=20221115093304)
- 장점
    1. HTTP/2에서 장점이었던 **멀티플렉싱** 지원
    2. **초기 연결 설정 시** **지연 시간 감소**라는 장점
- 초기 연결 설정 시 지연 시간 감소 (QUIC의 장점)
    1. QUIC은 UDP 기반이기에 3-way-handshake 과정을 거치지 않아도 됨
    2. QUIC은 첫 연결 설정에 TLS Handshake 통해 1-RTT만 소요됨 (cf. TCP에서는 3-RTT 소요)
        - RTT(Round Trip Time): 데이터 패킷이 출발 지점에서 도착 지점까지 이동하고 응답이 되돌아오는 데 소요되는 시간
    3. QUIC은 순방향 오류 수정 메커니즘(FEC, Forward Error Correction)이 적용됨
        - 전송한 패킷이 손실되었다면 수신 측에서 에러 검출하고 수정하는 방식
        - 열악한 네트워크 환경에서도 낮은 패킷 손실률 자랑

---

## 레퍼런스

- 참고 문서
    - [https://docs.tosspayments.com/resources/glossary/http-protocol#http-요청과-응답](https://docs.tosspayments.com/resources/glossary/http-protocol#http-%EC%9A%94%EC%B2%AD%EA%B3%BC-%EC%9D%91%EB%8B%B5)
    - HTTP/3: [https://medium.com/rate-labs/quic-프로토콜-구글-또-너야-932befde91a1](https://medium.com/rate-labs/quic-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EA%B5%AC%EA%B8%80-%EB%98%90-%EB%84%88%EC%95%BC-932befde91a1)
    - HTTP 메서드: [https://inpa.tistory.com/entry/WEB-🌐-HTTP-메서드-종류-통신-과정-💯-총정리](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A2%85%EB%A5%98-%ED%86%B5%EC%8B%A0-%EA%B3%BC%EC%A0%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC)
    - HTTP 요청과 응답: [응답 메시지에서 써야 할 HTTP 버전을 알려주는 역할](https://developer.mozilla.org/ko/docs/Web/HTTP/Messages)
    - HTTP 상태코드: [https://hongong.hanbit.co.kr/http-상태-코드-표-1xx-5xx-전체-요약-정리/](https://hongong.hanbit.co.kr/http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C-%ED%91%9C-1xx-5xx-%EC%A0%84%EC%B2%B4-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC/)
    - 쿠키 세션: [https://velog.io/@octo__/쿠키Cookie-세션Session](https://velog.io/@octo__/%EC%BF%A0%ED%82%A4Cookie-%EC%84%B8%EC%85%98Session)
- 이미지
    - HTTP 역사: [https://velog.io/@wlwl99/HTTP의-특징](https://velog.io/@wlwl99/HTTP%EC%9D%98-%ED%8A%B9%EC%A7%95)